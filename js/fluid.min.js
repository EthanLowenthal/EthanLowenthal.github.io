"use strict";
let refreshId, updateSim, htmlTexture, initFluid, startSim;
function queueRedraw() {
  clearTimeout(refreshId), (refreshId = setTimeout(updateSim, 500));
}
let fluidConfig = {
  SIM_RESOLUTION: 256,
  DYE_RESOLUTION: 1024,
  DENSITY_DISSIPATION: 0.5,
  VELOCITY_DISSIPATION: 0.2,
  PRESSURE: 0.5,
  PRESSURE_ITERATIONS: 20,
  CURL: 20,
  SPLAT_RADIUS: 0.25,
  SPLAT_FORCE: 15e3,
  COLOR_UPDATE_SPEED: 1,
  PAUSED: !1,
  BACK_COLOR: { r: 20, g: 20, b: 20 },
  TRANSPARENT: !1,
};
function pointerPrototype() {
  (this.id = -1),
    (this.texcoordX = 0),
    (this.texcoordY = 0),
    (this.prevTexcoordX = 0),
    (this.prevTexcoordY = 0),
    (this.deltaX = 0),
    (this.deltaY = 0),
    (this.down = !1),
    (this.moved = !1),
    (this.color = [30, 0, 300]);
}
let pointers = [],
  splatStack = [];
pointers.push(new pointerPrototype()),
  window.addEventListener("load", () => {
    const e = document.getElementById("fluid-canvas");
    z();
    const { gl: t, ext: n } = (function (e) {
      const t = {
        alpha: !0,
        depth: !1,
        stencil: !1,
        antialias: !1,
        preserveDrawingBuffer: !1,
      };
      let n = e.getContext("webgl2", t);
      const i = !!n;
      i ||
        (n = e.getContext("webgl", t) || e.getContext("experimental-webgl", t));
      let o, a;
      i
        ? (n.getExtension("EXT_color_buffer_float"),
          (a = n.getExtension("OES_texture_float_linear")))
        : ((o = n.getExtension("OES_texture_half_float")),
          (a = n.getExtension("OES_texture_half_float_linear")));
      n.clearColor(0, 0, 0, 1);
      const u = i ? n.HALF_FLOAT : o.HALF_FLOAT_OES;
      let f, l, c;
      i
        ? ((f = r(n, n.RGBA16F, n.RGBA, u)),
          (l = r(n, n.RG16F, n.RG, u)),
          (c = r(n, n.R16F, n.RED, u)))
        : ((f = r(n, n.RGBA, n.RGBA, u)),
          (l = r(n, n.RGBA, n.RGBA, u)),
          (c = r(n, n.RGBA, n.RGBA, u)));
      return {
        gl: n,
        ext: {
          formatRGBA: f,
          formatRG: l,
          formatR: c,
          halfFloatTexType: u,
          supportLinearFiltering: a,
        },
      };
    })(e);
    function r(e, t, n, i) {
      if (
        !(function (e, t, n, r) {
          let i = e.createTexture();
          e.bindTexture(e.TEXTURE_2D, i),
            e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, e.NEAREST),
            e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MAG_FILTER, e.NEAREST),
            e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, e.CLAMP_TO_EDGE),
            e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, e.CLAMP_TO_EDGE),
            e.texImage2D(e.TEXTURE_2D, 0, t, 4, 4, 0, n, r, null);
          let o = e.createFramebuffer();
          return (
            e.bindFramebuffer(e.FRAMEBUFFER, o),
            e.framebufferTexture2D(
              e.FRAMEBUFFER,
              e.COLOR_ATTACHMENT0,
              e.TEXTURE_2D,
              i,
              0
            ),
            e.checkFramebufferStatus(e.FRAMEBUFFER) == e.FRAMEBUFFER_COMPLETE
          );
        })(e, t, n, i)
      )
        switch (t) {
          case e.R16F:
            return r(e, e.RG16F, e.RG, i);
          case e.RG16F:
            return r(e, e.RGBA16F, e.RGBA, i);
          default:
            return null;
        }
      return { internalFormat: t, format: n };
    }
    /Mobi|Android/i.test(navigator.userAgent) &&
      (fluidConfig.DYE_RESOLUTION = 512),
      n.supportLinearFiltering || (fluidConfig.DYE_RESOLUTION = 512);
    class i {
      constructor(e, t) {
        (this.uniforms = {}),
          (this.program = o(e, t)),
          (this.uniforms = a(this.program));
      }
      bind() {
        t.useProgram(this.program);
      }
    }
    function o(e, n) {
      let r = t.createProgram();
      return (
        t.attachShader(r, e),
        t.attachShader(r, n),
        t.linkProgram(r),
        t.getProgramParameter(r, t.LINK_STATUS) ||
          console.trace(t.getProgramInfoLog(r)),
        r
      );
    }
    function a(e) {
      let n = [],
        r = t.getProgramParameter(e, t.ACTIVE_UNIFORMS);
      for (let i = 0; i < r; i++) {
        let r = t.getActiveUniform(e, i).name;
        n[r] = t.getUniformLocation(e, r);
      }
      return n;
    }
    function u(e, n, r) {
      n = (function (e, t) {
        if (null == t) return e;
        let n = "";
        return (
          t.forEach((e) => {
            n += "#define " + e + "\n";
          }),
          n + e
        );
      })(n, r);
      const i = t.createShader(e);
      return (
        t.shaderSource(i, n),
        t.compileShader(i),
        t.getShaderParameter(i, t.COMPILE_STATUS) ||
          console.trace(t.getShaderInfoLog(i)),
        i
      );
    }
    const f = u(
        t.VERTEX_SHADER,
        "\n    precision highp float;\n\n    attribute vec2 aPosition;\n    varying vec2 vUv;\n    varying vec2 vL;\n    varying vec2 vR;\n    varying vec2 vT;\n    varying vec2 vB;\n    uniform vec2 texelSize;\n\n    void main () {\n        vUv = aPosition * 0.5 + 0.5;\n        vL = vUv - vec2(texelSize.x, 0.0);\n        vR = vUv + vec2(texelSize.x, 0.0);\n        vT = vUv + vec2(0.0, texelSize.y);\n        vB = vUv - vec2(0.0, texelSize.y);\n        gl_Position = vec4(aPosition, 0.0, 1.0);\n    }\n"
      ),
      l = u(
        t.FRAGMENT_SHADER,
        "\n    precision mediump float;\n    precision mediump sampler2D;\n\n    varying highp vec2 vUv;\n    uniform sampler2D uTexture;\n\n    void main () {\n        gl_FragColor = texture2D(uTexture, vUv);\n    }\n"
      ),
      c = u(
        t.FRAGMENT_SHADER,
        "\n    precision mediump float;\n    precision mediump sampler2D;\n\n    varying highp vec2 vUv;\n    uniform sampler2D uTexture;\n    uniform float value;\n\n    void main () {\n        gl_FragColor = value * texture2D(uTexture, vUv);\n    }\n"
      ),
      s = u(
        t.FRAGMENT_SHADER,
        "\n    precision mediump float;\n\n    uniform vec4 color;\n\n    void main () {\n        gl_FragColor = color;\n    }\n"
      ),
      v = u(
        t.FRAGMENT_SHADER,
        "\n    precision highp float;\n    precision highp sampler2D;\n\n    varying vec2 vUv;\n    uniform sampler2D uTexture;\n    uniform float aspectRatio;\n\n    #define SCALE 25.0\n\n    void main () {\n        vec2 uv = floor(vUv * SCALE * vec2(aspectRatio, 1.0));\n        float v = mod(uv.x + uv.y, 2.0);\n        v = v * 0.1 + 0.8;\n        gl_FragColor = vec4(vec3(v), 1.0);\n    }\n"
      ),
      m = u(
        t.FRAGMENT_SHADER,
        "\n    precision highp float;\n    precision highp sampler2D;\n\n    varying vec2 vUv;\n    uniform sampler2D uTarget;\n    uniform float aspectRatio;\n    uniform vec3 color;\n    uniform vec2 point;\n    uniform float radius;\n\n    void main () {\n        vec2 p = vUv - point.xy;\n        p.x *= aspectRatio;\n        vec3 splat = exp(-dot(p, p) / radius) * color;\n        vec3 base = texture2D(uTarget, vUv).xyz;\n        gl_FragColor = vec4(base + splat, 1.0);\n    }\n"
      ),
      d = u(
        t.FRAGMENT_SHADER,
        "\n    precision highp float;\n    precision highp sampler2D;\n\n    varying vec2 vUv;\n    uniform sampler2D uVelocity;\n    uniform sampler2D uSource;\n    uniform vec2 texelSize;\n    uniform vec2 dyeTexelSize;\n    uniform float dt;\n    uniform float dissipation;\n\n    vec4 bilerp (sampler2D sam, vec2 uv, vec2 tsize) {\n        vec2 st = uv / tsize - 0.5;\n\n        vec2 iuv = floor(st);\n        vec2 fuv = fract(st);\n\n        vec4 a = texture2D(sam, (iuv + vec2(0.5, 0.5)) * tsize);\n        vec4 b = texture2D(sam, (iuv + vec2(1.5, 0.5)) * tsize);\n        vec4 c = texture2D(sam, (iuv + vec2(0.5, 1.5)) * tsize);\n        vec4 d = texture2D(sam, (iuv + vec2(1.5, 1.5)) * tsize);\n\n        return mix(mix(a, b, fuv.x), mix(c, d, fuv.x), fuv.y);\n    }\n\n    void main () {\n    #ifdef MANUAL_FILTERING\n        vec2 coord = vUv - dt * bilerp(uVelocity, vUv, texelSize).xy * texelSize;\n        vec4 result = bilerp(uSource, coord, dyeTexelSize);\n    #else\n        vec2 coord = vUv - dt * texture2D(uVelocity, vUv).xy * texelSize;\n        vec4 result = texture2D(uSource, coord);\n    #endif\n        float decay = 1.0 + dissipation * dt;\n        gl_FragColor = result / decay;\n    }",
        n.supportLinearFiltering ? null : ["MANUAL_FILTERING"]
      ),
      h = u(
        t.FRAGMENT_SHADER,
        "\n    precision mediump float;\n    precision mediump sampler2D;\n\n    varying highp vec2 vUv;\n    varying highp vec2 vL;\n    varying highp vec2 vR;\n    varying highp vec2 vT;\n    varying highp vec2 vB;\n    uniform sampler2D uVelocity;\n\n    void main () {\n        float L = texture2D(uVelocity, vL).x;\n        float R = texture2D(uVelocity, vR).x;\n        float T = texture2D(uVelocity, vT).y;\n        float B = texture2D(uVelocity, vB).y;\n\n        vec2 C = texture2D(uVelocity, vUv).xy;\n        if (vL.x < 0.0) { L = -C.x; }\n        if (vR.x > 1.0) { R = -C.x; }\n        if (vT.y > 1.0) { T = -C.y; }\n        if (vB.y < 0.0) { B = -C.y; }\n\n        float div = 0.5 * (R - L + T - B);\n        gl_FragColor = vec4(div, 0.0, 0.0, 1.0);\n    }\n"
      ),
      g = u(
        t.FRAGMENT_SHADER,
        "\n    precision mediump float;\n    precision mediump sampler2D;\n\n    varying highp vec2 vUv;\n    varying highp vec2 vL;\n    varying highp vec2 vR;\n    varying highp vec2 vT;\n    varying highp vec2 vB;\n    uniform float basePressure;\n    uniform sampler2D uPressure;\n    uniform sampler2D uDivergence;\n    uniform sampler2D uText;\n\n    void main () {\n        float L = texture2D(uPressure, vL).x;\n        float R = texture2D(uPressure, vR).x;\n        float T = texture2D(uPressure, vT).x;\n        float B = texture2D(uPressure, vB).x;\n        float C = texture2D(uPressure, vUv).x;\n        float divergence = texture2D(uDivergence, vUv).x;\n        float pressure = (L + R + B + T - divergence) * 0.25;\n\n        vec3 t = texture2D(uText, vec2(vUv.x,1.-vUv.y)).xyz;\n\n        if (t.x + t.y + t.z > 1.) {\n             pressure = basePressure;\n        }\n        gl_FragColor = vec4(pressure, 0.0, 0.0, 1.0);\n    }\n"
      ),
      T = u(
        t.FRAGMENT_SHADER,
        "\n    precision mediump float;\n    precision mediump sampler2D;\n\n    varying highp vec2 vUv;\n    varying highp vec2 vL;\n    varying highp vec2 vR;\n    varying highp vec2 vT;\n    varying highp vec2 vB;\n    uniform sampler2D uPressure;\n    uniform sampler2D uVelocity;\n    uniform sampler2D uText;\n\n    void main () {\n        float L = texture2D(uPressure, vL).x;\n        float R = texture2D(uPressure, vR).x;\n        float T = texture2D(uPressure, vT).x;\n        float B = texture2D(uPressure, vB).x;\n        vec2 velocity = texture2D(uVelocity, vUv).xy;\n        velocity.xy -= vec2(R - L, T - B);\n        vec3 t = texture2D(uText, vec2(vUv.x,1.-vUv.y)).xyz;\n\n        if (t.x + t.y + t.z > 1.) {\n             velocity = vec2(0.);\n        }\n        gl_FragColor = vec4(velocity, 0.0, 1.0);\n    }\n"
      ),
      E = (() => (
        t.bindBuffer(t.ARRAY_BUFFER, t.createBuffer()),
        t.bufferData(
          t.ARRAY_BUFFER,
          new Float32Array([-1, -1, -1, 1, 1, 1, 1, -1]),
          t.STATIC_DRAW
        ),
        t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, t.createBuffer()),
        t.bufferData(
          t.ELEMENT_ARRAY_BUFFER,
          new Uint16Array([0, 1, 2, 0, 2, 3]),
          t.STATIC_DRAW
        ),
        t.vertexAttribPointer(0, 2, t.FLOAT, !1, 0, 0),
        t.enableVertexAttribArray(0),
        (e, n = !1) => {
          null == e
            ? (t.viewport(0, 0, t.drawingBufferWidth, t.drawingBufferHeight),
              t.bindFramebuffer(t.FRAMEBUFFER, null))
            : (t.viewport(0, 0, e.width, e.height),
              t.bindFramebuffer(t.FRAMEBUFFER, e.fbo)),
            n && (t.clearColor(0, 0, 0, 1), t.clear(t.COLOR_BUFFER_BIT)),
            t.drawElements(t.TRIANGLES, 6, t.UNSIGNED_SHORT, 0);
        }
      ))();
    let x, R, p, S;
    const A = new i(f, l),
      D = new i(f, c),
      _ = new i(f, s),
      U = new i(f, v),
      F = new i(f, m),
      w = new i(f, d),
      y = new i(f, h),
      L = new i(f, g),
      P = new i(f, T),
      C = new (class {
        constructor(e, t) {
          (this.vertexShader = e),
            (this.fragmentShaderSource = t),
            (this.programs = []),
            (this.activeProgram = null),
            (this.uniforms = []);
        }
        setKeywords(e) {
          let n = 0;
          for (let t = 0; t < e.length; t++) n += k(e[t]);
          let r = this.programs[n];
          if (null == r) {
            let i = u(t.FRAGMENT_SHADER, this.fragmentShaderSource, e);
            (r = o(this.vertexShader, i)), (this.programs[n] = r);
          }
          r != this.activeProgram &&
            ((this.uniforms = a(r)), (this.activeProgram = r));
        }
        bind() {
          t.useProgram(this.activeProgram);
        }
      })(
        f,
        "\n    precision highp float;\n    precision highp sampler2D;\n\n    varying vec2 vUv;\n    varying vec2 vL;\n    varying vec2 vR;\n    varying vec2 vT;\n    varying vec2 vB;\n    uniform sampler2D uTexture;\n    uniform sampler2D uText;\n    uniform sampler2D uDithering;\n    uniform vec2 ditherScale;\n    uniform vec2 texelSize;\n\n    vec3 linearToGamma (vec3 color) {\n        color = max(color, vec3(0));\n        return max(1.055 * pow(color, vec3(0.416666667)) - 0.055, vec3(0));\n    }\n\n    void main () {\n        vec3 c = texture2D(uTexture, vUv).rgb;\n\n        float a = max(c.r, max(c.g, c.b));\n        gl_FragColor = vec4(c, a);\n    }\n"
      );
    function b() {
      let e = V(fluidConfig.SIM_RESOLUTION),
        r = V(fluidConfig.DYE_RESOLUTION);
      const i = n.halfFloatTexType,
        o = n.formatRGBA,
        a = n.formatRG,
        u = n.formatR,
        f = n.supportLinearFiltering ? t.LINEAR : t.NEAREST;
      t.disable(t.BLEND),
        null == htmlTexture &&
          (htmlTexture = B(
            e.width,
            e.height,
            u.internalFormat,
            u.format,
            i,
            t.NEAREST
          )),
        (x =
          null == x
            ? I(r.width, r.height, o.internalFormat, o.format, i, f)
            : N(x, r.width, r.height, o.internalFormat, o.format, i, f)),
        (R =
          null == R
            ? I(e.width, e.height, a.internalFormat, a.format, i, f)
            : N(R, e.width, e.height, a.internalFormat, a.format, i, f)),
        (p = B(e.width, e.height, u.internalFormat, u.format, i, t.NEAREST)),
        (S = I(e.width, e.height, u.internalFormat, u.format, i, t.NEAREST));
    }
    function B(e, n, r, i, o, a) {
      t.activeTexture(t.TEXTURE0);
      let u = t.createTexture();
      t.bindTexture(t.TEXTURE_2D, u),
        t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MIN_FILTER, a),
        t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MAG_FILTER, a),
        t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_S, t.CLAMP_TO_EDGE),
        t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_T, t.CLAMP_TO_EDGE),
        t.texImage2D(t.TEXTURE_2D, 0, r, e, n, 0, i, o, null);
      let f = t.createFramebuffer();
      return (
        t.bindFramebuffer(t.FRAMEBUFFER, f),
        t.framebufferTexture2D(
          t.FRAMEBUFFER,
          t.COLOR_ATTACHMENT0,
          t.TEXTURE_2D,
          u,
          0
        ),
        t.viewport(0, 0, e, n),
        t.clear(t.COLOR_BUFFER_BIT),
        {
          texture: u,
          fbo: f,
          width: e,
          height: n,
          texelSizeX: 1 / e,
          texelSizeY: 1 / n,
          attach: (e) => (
            t.activeTexture(t.TEXTURE0 + e), t.bindTexture(t.TEXTURE_2D, u), e
          ),
        }
      );
    }
    function I(e, t, n, r, i, o) {
      let a = B(e, t, n, r, i, o),
        u = B(e, t, n, r, i, o);
      return {
        width: e,
        height: t,
        texelSizeX: a.texelSizeX,
        texelSizeY: a.texelSizeY,
        get read() {
          return a;
        },
        set read(e) {
          a = e;
        },
        get write() {
          return u;
        },
        set write(e) {
          u = e;
        },
        swap() {
          let e = a;
          (a = u), (u = e);
        },
      };
    }
    function N(e, n, r, i, o, a, u) {
      return e.width == n && e.height == r
        ? e
        : ((e.read = (function (e, n, r, i, o, a, u) {
            let f = B(n, r, i, o, a, u);
            return (
              A.bind(), t.uniform1i(A.uniforms.uTexture, e.attach(0)), E(f), f
            );
          })(e.read, n, r, i, o, a, u)),
          (e.write = B(n, r, i, o, a, u)),
          (e.width = n),
          (e.height = r),
          (e.texelSizeX = 1 / n),
          (e.texelSizeY = 1 / r),
          e);
    }
    (initFluid = b), C.setKeywords([]), b();
    let O = Date.now(),
      X = 0,
      M = 0;
    function z() {
      let t = W(e.clientWidth),
        n = W(e.clientHeight);
      return (
        (e.width != t || e.height != n) && ((e.width = t), (e.height = n), !0)
      );
    }
    function G(e) {
      for (let t = 0; t < e; t++) {
        const e = H(10);
        Y(
          Math.random(),
          Math.random(),
          1e3 * (Math.random() - 0.5),
          1e3 * (Math.random() - 0.5),
          e
        );
      }
    }
    function Y(n, r, i, o, a) {
      F.bind(),
        t.uniform1i(F.uniforms.uTarget, R.read.attach(0)),
        t.uniform1f(F.uniforms.aspectRatio, e.width / e.height),
        t.uniform2f(F.uniforms.point, n, r),
        t.uniform3f(F.uniforms.color, i, o, 0),
        t.uniform1f(
          F.uniforms.radius,
          (function (t) {
            let n = e.width / e.height;
            n > 1 && (t *= n);
            return t;
          })(fluidConfig.SPLAT_RADIUS / 100)
        ),
        E(R.write),
        R.swap(),
        t.uniform1i(F.uniforms.uTarget, x.read.attach(0)),
        t.uniform3f(F.uniforms.color, a.r, a.g, a.b),
        E(x.write),
        x.swap();
    }
    function H(e) {
      let t = (function (e, t, n) {
        let r, i, o, a, u, f, l, c;
        switch (
          ((a = Math.floor(6 * e)),
          (f = n * (1 - t)),
          (l = n * (1 - (u = 6 * e - a) * t)),
          (c = n * (1 - (1 - u) * t)),
          a % 6)
        ) {
          case 0:
            (r = n), (i = c), (o = f);
            break;
          case 1:
            (r = l), (i = n), (o = f);
            break;
          case 2:
            (r = f), (i = n), (o = c);
            break;
          case 3:
            (r = f), (i = l), (o = n);
            break;
          case 4:
            (r = c), (i = f), (o = n);
            break;
          case 5:
            (r = n), (i = f), (o = l);
        }
        return { r: r, g: i, b: o };
      })(Math.random(), 1, 1);
      return (t.r *= 0.15 * e), (t.g *= 0.15 * e), (t.b *= 0.15 * e), t;
    }
    function V(e) {
      let n = t.drawingBufferWidth / t.drawingBufferHeight;
      n < 1 && (n = 1 / n);
      let r = Math.round(e),
        i = Math.round(e * n);
      return t.drawingBufferWidth > t.drawingBufferHeight
        ? { width: i, height: r }
        : { width: r, height: i };
    }
    function W(e) {
      let t = window.devicePixelRatio || 1;
      return Math.floor(e * t);
    }
    function k(e) {
      if (0 == e.length) return 0;
      let t = 0;
      for (let n = 0; n < e.length; n++)
        (t = (t << 5) - t + e.charCodeAt(n)), (t |= 0);
      return t;
    }
    function K() {
      const e = document.getElementById("root");
      e.classList.add("nounderline"),
        html2canvas(document.body).then(function (e) {
          (fluidConfig.PAUSED = !0),
            htmlTexture.attach(0),
            t.texImage2D(t.TEXTURE_2D, 0, t.RGBA, t.RGBA, t.UNSIGNED_BYTE, e),
            (fluidConfig.PAUSED = !1);
        }),
        e.classList.remove("nounderline");
    }
    (startSim = function r(i = 0) {
      const o = (function () {
        let e = Date.now(),
          t = (e - O) / 1e3;
        return (t = Math.min(t, 0.016666)), (O = e), t;
      })();
      z() && b(),
        (function (e) {
          (X += e * fluidConfig.COLOR_UPDATE_SPEED) >= 1 &&
            ((X = (function (e, t, n) {
              let r = n - t;
              return 0 == r ? t : ((e - t) % r) + t;
            })(X, 0, 1)),
            pointers.forEach((e) => {
              e.color = H(0.75);
            }));
        })(o),
        splatStack.length > 0 && G(splatStack.pop()),
        pointers.forEach((e) => {
          e.moved &&
            ((e.moved = !1),
            (function (e) {
              let t = e.deltaX * fluidConfig.SPLAT_FORCE,
                n = e.deltaY * fluidConfig.SPLAT_FORCE;
              Y(e.texcoordX, e.texcoordY, t, n, e.color);
            })(e));
        });
      let a = fluidConfig.SPLAT_RADIUS;
      (fluidConfig.SPLAT_RADIUS = 0.075),
        Y(0.9, 0.7, -10, 0, {
          r: 0,
          g: 0.03 + 0.01 * Math.sin(0.00684 * i * 0),
          b: 0.05 + 0.03 * Math.sin(0.005 * i),
        }),
        i - M > 1e3 && (G(1), (M = i)),
        (fluidConfig.SPLAT_RADIUS = a),
        fluidConfig.PAUSED ||
          (function (e) {
            t.disable(t.BLEND),
              y.bind(),
              t.uniform2f(y.uniforms.texelSize, R.texelSizeX, R.texelSizeY),
              t.uniform1i(y.uniforms.uVelocity, R.read.attach(0)),
              E(p),
              D.bind(),
              t.uniform1i(D.uniforms.uTexture, S.read.attach(0)),
              t.uniform1f(D.uniforms.value, fluidConfig.PRESSURE),
              E(S.write),
              S.swap(),
              L.bind(),
              t.uniform2f(L.uniforms.texelSize, R.texelSizeX, R.texelSizeY),
              t.uniform1f(L.uniforms.basePressure, fluidConfig.PRESSURE),
              t.uniform1i(L.uniforms.uDivergence, p.attach(0)),
              t.uniform1i(L.uniforms.uText, htmlTexture.attach(2));
            for (let e = 0; e < fluidConfig.PRESSURE_ITERATIONS; e++)
              t.uniform1i(L.uniforms.uPressure, S.read.attach(1)),
                E(S.write),
                S.swap();
            V(fluidConfig.SIM_RESOLUTION),
              P.bind(),
              t.uniform2f(P.uniforms.texelSize, R.texelSizeX, R.texelSizeY),
              t.uniform1i(P.uniforms.uPressure, S.read.attach(0)),
              t.uniform1i(P.uniforms.uVelocity, R.read.attach(1)),
              t.uniform1i(P.uniforms.uText, htmlTexture.attach(2)),
              E(R.write),
              R.swap(),
              w.bind(),
              t.uniform2f(w.uniforms.texelSize, R.texelSizeX, R.texelSizeY),
              n.supportLinearFiltering ||
                t.uniform2f(
                  w.uniforms.dyeTexelSize,
                  R.texelSizeX,
                  R.texelSizeY
                );
            let r = R.read.attach(0);
            t.uniform1i(w.uniforms.uVelocity, r),
              t.uniform1i(w.uniforms.uSource, r),
              t.uniform1f(w.uniforms.dt, e),
              t.uniform1f(
                w.uniforms.dissipation,
                fluidConfig.VELOCITY_DISSIPATION
              ),
              E(R.write),
              R.swap(),
              n.supportLinearFiltering ||
                t.uniform2f(
                  w.uniforms.dyeTexelSize,
                  x.texelSizeX,
                  x.texelSizeY
                ),
              t.uniform1i(w.uniforms.uVelocity, R.read.attach(0)),
              t.uniform1i(w.uniforms.uSource, x.read.attach(1)),
              t.uniform1f(
                w.uniforms.dissipation,
                fluidConfig.DENSITY_DISSIPATION
              ),
              E(x.write),
              x.swap();
          })(o),
        (u = null),
        null != u && fluidConfig.TRANSPARENT
          ? t.disable(t.BLEND)
          : (t.blendFunc(t.ONE, t.ONE_MINUS_SRC_ALPHA), t.enable(t.BLEND)),
        fluidConfig.TRANSPARENT ||
          (function (e, n) {
            _.bind(), t.uniform4f(_.uniforms.color, n.r, n.g, n.b, 1), E(e);
          })(u, {
            r: (f = fluidConfig.BACK_COLOR).r / 255,
            g: f.g / 255,
            b: f.b / 255,
          }),
        null == u &&
          fluidConfig.TRANSPARENT &&
          (function (n) {
            U.bind(),
              t.uniform1f(U.uniforms.aspectRatio, e.width / e.height),
              E(n);
          })(u),
        (function (e) {
          null == e ? t.drawingBufferWidth : e.width,
            null == e ? t.drawingBufferHeight : e.height,
            C.bind(),
            t.uniform1i(C.uniforms.uTexture, x.read.attach(0)),
            t.uniform1i(C.uniforms.uText, htmlTexture.attach(1)),
            E(e);
        })(u),
        requestAnimationFrame(r);
      var u, f;
    }),
      e.addEventListener("mousedown", (t) => {
        W(t.offsetX), W(t.offsetY);
        let n = pointers.find((e) => -1 == e.id);
        null == n && (n = new pointerPrototype()),
          (function (t, n, r, i) {
            (t.id = n),
              (t.down = !0),
              (t.moved = !1),
              (t.texcoordX = r / e.width),
              (t.texcoordY = 1 - i / e.height),
              (t.prevTexcoordX = t.texcoordX),
              (t.prevTexcoordY = t.texcoordY),
              (t.deltaX = 0),
              (t.deltaY = 0),
              (t.color = H(0.75));
          })(n, -1, t.offsetX, t.offsetY);
      }),
      e.addEventListener("mousemove", (t) => {
        let n = pointers[0];
        n.down &&
          (function (t, n, r) {
            (t.prevTexcoordX = t.texcoordX),
              (t.prevTexcoordY = t.texcoordY),
              (t.texcoordX = n / e.width),
              (t.texcoordY = 1 - r / e.height),
              (t.deltaX = (function (t) {
                let n = e.width / e.height;
                n < 1 && (t *= n);
                return t;
              })(t.texcoordX - t.prevTexcoordX)),
              (t.deltaY = (function (t) {
                let n = e.width / e.height;
                n > 1 && (t /= n);
                return t;
              })(t.texcoordY - t.prevTexcoordY)),
              (t.moved = Math.abs(t.deltaX) > 0 || Math.abs(t.deltaY) > 0);
          })(n, W(t.offsetX), W(t.offsetY));
      }),
      window.addEventListener("mouseup", () => {
        !(function (e) {
          e.down = !1;
        })(pointers[0]);
      }),
      window.addEventListener("resize", () => {
        queueRedraw();
      }),
      (updateSim = K),
      K();
  });
